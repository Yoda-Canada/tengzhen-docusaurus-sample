"use strict";(self.webpackChunktengzhen_website=self.webpackChunktengzhen_website||[]).push([[2984],{3905:function(e,t,n){n.d(t,{Zo:function(){return h},kt:function(){return p}});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=o.createContext({}),u=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},h=function(e){var t=u(e.components);return o.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),d=u(n),p=a,g=d["".concat(l,".").concat(p)]||d[p]||c[p]||r;return n?o.createElement(g,i(i({ref:t},h),{},{components:n})):o.createElement(g,i({ref:t},h))}));function p(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var u=2;u<r;u++)i[u]=n[u];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},7209:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return u},assets:function(){return h},toc:function(){return c},default:function(){return p}});var o=n(7462),a=n(3366),r=(n(7294),n(3905)),i=["components"],s={slug:"Node-introduction-post",title:"Node.js is the New Black",authors:"Louis",tags:["Node"]},l=void 0,u={permalink:"/tengzhen-docusaurus-sample/blog/Node-introduction-post",editUrl:"https://github.com/Yoda-Canada.github.io/tengzhen-docusaurus-sample/edit/main/website/blog/blog/2010-07-13-Node-introduction.md",source:"@site/blog/2010-07-13-Node-introduction.md",title:"Node.js is the New Black",description:"If you\u2019ve been paying attention to news about web technology in the last year, you\u2019ve most likely heard the name node.js mentioned at least once or twice. What happened next probably went like this: you asked, \u201cWhat is it?\u201d and someone (or Google) told you that it was a way to write web servers using JavaScript. If that didn\u2019t scare you away, you might then have asked, \u201cWhy would you want to use it?\u201d and the answer might have been along the lines of it taking advantage of non-blocking, event-driven IO to enable high concurrency in long polling or comet-based applications.",date:"2010-07-13T00:00:00.000Z",formattedDate:"July 13, 2010",tags:[{label:"Node",permalink:"/tengzhen-docusaurus-sample/blog/tags/node"}],readingTime:4.26,truncated:!1,authors:[{name:"Louis Simoneau",title:"Node.js is the New Black",url:"https://www.sitepoint.com/node-js-is-the-new-black/",imageURL:"https://github.com/louis1.png",key:"Louis"}],prevItem:{title:"First Blog Post",permalink:"/tengzhen-docusaurus-sample/blog/first-blog-post"}},h={authorsImageUrls:[void 0]},c=[],d={toc:c};function p(e){var t=e.components,n=(0,a.Z)(e,i);return(0,r.kt)("wrapper",(0,o.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"If you\u2019ve been paying attention to news about web technology in the last year, you\u2019ve most likely heard the name node.js mentioned at least once or twice. What happened next probably went like this: you asked, \u201cWhat is it?\u201d and someone (or Google) told you that it was a way to write web servers using JavaScript. If that didn\u2019t scare you away, you might then have asked, \u201cWhy would you want to use it?\u201d and the answer might have been along the lines of it taking advantage of non-blocking, event-driven IO to enable high concurrency in long polling or comet-based applications."),(0,r.kt)("p",null,"At which point you stopped asking questions. I don\u2019t blame you. To help break apart that wall of jargon, here\u2019s my attempt at explaining what node.js is and why you should be paying attention to it."),(0,r.kt)("p",null,"So here\u2019s how it is, how it\u2019s always been: a browser sends a request to a website. The site\u2019s server receives the request, tracks down the requested file, performs any database queries as needed, and sends a response to the browser. In traditional web servers, such as Apache, each request causes the server to create a new system process to handle that request."),(0,r.kt)("p",null,"Then there was Ajax. Instead of requesting a whole new page each time, we\u2019d only request the piece of information we actually wanted. Okay, that\u2019s an improvement."),(0,r.kt)("p",null,"But now think about how you\u2019d go about building a service like FriendFeed, where each user\u2019s feed is updating in real time, all the time. The only way that\u2019s possible is if each user has an active connection to the server at all times. The simplest way to do that at present is through long polling."),(0,r.kt)("p",null,"Long polling essentially tricks HTTP into acting like a persistent connection: as soon as the page loads, it fires off an Ajax request to the server, even if the page doesn\u2019t want anything in particular. But, unlike a normal Ajax request, the server doesn\u2019t respond right away. It just waits, and fires back a response only when it has something new it wants the browser to display. For example, as soon as one of your friends adds a new post, the server returns the response telling the browser to update its display. As soon as the browser receives the response, it shoots back another request. This way the browser is always waiting for a new event to happen on the server side."),(0,r.kt)("p",null,"Now think about what that means for a traditional web server like Apache. For each and every user connected to the site, your server has to keep a connection open. Each connection requires a process, and each of those processes will spend most of its time either sitting idle (consuming memory) or waiting on a database query to complete. This means that it\u2019s hard to scale up to high numbers of connections without grinding to a near halt and using up all your resources."),(0,r.kt)("p",null,"So what\u2019s the solution? Here\u2019s where some of that jargon from before comes into play: specifically non-blocking and event-driven. What those terms mean in this context is less complicated than you might fear. Think of a non-blocking server as a loop: it just keeps going round and round. A request comes in, the loop grabs it, passes it along to some other process (like a database query), sets up a callback, and keeps going round, ready for the next request. It doesn\u2019t just sit there, waiting for the database to come back with the requested info."),(0,r.kt)("p",null,"If the database query comes back \u2014 fine, we\u2019ll deal with that the same way: throw a response back to the client and keep looping around. There\u2019s theoretically no limit on how many database queries you can be waiting on, or how many clients have open requests, because you\u2019re not spending any time waiting for them. You deal with them all in their own time, and that\u2019s what event-driven means: the server only reacts when an event occurs. That could be a request, a file being loaded, or a query being executed \u2014 it really doesn\u2019t matter."),(0,r.kt)("p",null,"FriendFeed uses a non-blocking framework written in Python, called Tornado, to do this. The nginx web server also behaves in this way. Node.js, however, has an ace up its sleeve: because it\u2019s using JavaScript \u2014 running on Google\u2019s crazy-fast V8 engine \u2014 it never needs to worry about whether a request it makes to another piece of code might cause the loop to block up. The reason is that JavaScript is intrinsically event-driven. Think about it: when you write JavaScript for the browser, you\u2019re just attaching event handlers and callbacks. That\u2019s the way the language was designed."),(0,r.kt)("p",null,"Node.js is still in its infancy, so if you want to write an application based on it you\u2019ll need to do some fairly low-level coding. But with the impending arrival of WebSockets in next-generation browsers (eliminating the need for long polling altogether), this type of technology will only become more important on the Web. I hope I\u2019ve given you the incentive to start messing around and getting your head around these concepts."),(0,r.kt)("p",null,"Translation\uff1a",(0,r.kt)("a",{parentName:"p",href:"https://www.zhihu.com/question/33578075/answer/56951771"},"https://www.zhihu.com/question/33578075/answer/56951771")))}p.isMDXComponent=!0}}]);